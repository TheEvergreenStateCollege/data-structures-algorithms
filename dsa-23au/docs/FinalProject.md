# Final Project and Independent Contract

This document describes 1/3 of your credit and evaluation for DSA students, and all of your credit
and evaluation if you have taken DSA before and are doing an independent, in-program learning contract
with Paul.

For DSA students, I'd like to see a progressively realized project demonstrating your data structures and algorithms skills
and also your ability to find and develop them in a Real-World Application throughout the quarter.

For independent students, I'd like to see the ability to apply your computer science skills to a
problem that is personally interesting to you. It may be to make progress on a project that
you have previously started. Your goal during this quarter is to show software engineering
judgment for *time estimation* and your *circle of competence*.

That is, it's an attempt to carve out
a smaller piece of a possibly bigger project or life goal and make a commitment to another person
(a faculty member, and optionally a classmate that you exchange your contract with).
It requires knowledge of yourself and your current capabilities, as well as the desire to steer
where you want to go.

## Deliverables for All Projects (DSA and Independent)

You can apply the criteria below, or present a case in your proposal for alternative
criteria that meets the intent of showing substantial effort for upper division computer science credit.

Per team member:
* 500 lines of original code, newly written or refactored while maintaining existing functionality, written this quarter
* 5 tests showing how to run your code and demonstrating 5 different modes of operation or functionality.
  * These can be unit tests written in code, integration tests written as a script, screenrecording videos, screenshots

For the whole project:
* A three-page or longer report describing
  * What you learned
  * New functionality or properties of your code
  * The technology stack you used and why,
  * Strengths of your work
  * Challenges you encountered and how you handled them
  * Opportunities for growth and future direction

You can incorporate some or all of the above sections into your required Evergreen self evaluation.

For example: if you have two members of your team, you'll each need to contribute 500 lines of code or code changes.

## Credits and Team 

One-third of your credits and evaluation this quarter will be based on your final project,
which will be done as a team that you choose among classmates in both the
Data Structures and Algorithms program and the Changemakers business program. Teams may be 
solo (one person) or up to 20 people. You will have to do some legwork and talk to your
classmates to learn what teams may be forming and how you can contribute!

We recommend and will support you in pushing outside your comfort zone. If you normally 
prefer to work alone, we suggest finding teammates, and if you normally like to work with 
teammates, we suggest going it alone. But no matter what, the teaching staff and your classmates
will be here to talk and go through the experience with you.

## Progression Through 10 Weeks 

While each week we will introduce new concepts, data structures, and algorithms, and 
self-contained homework exercises to help you learn, you will be progressively synthesizing these 
learnings, adding them to your final project.

At the end, you will have the following deliverables to submit to instructors as well as a 
portfolio piece that you can display on your Git profiles, your websites and social media,
and as a starting point for your work in later quarters (Purpose Driven Web in Winter 2024
and Software Construction in Spring 2024).

## Criteria

* Use and combine at least four data structures (beyond an array or a linked list) or algorithms.
* Be compelling for you and your team. It doesn't have to appeal to anyone else but you and your teammates.
You'll be working on this problem for 10 weeks, so when you think of the project, you want to feel 
a certain eagerness to make progress.
* Describe your *invariant*, in both plain English and in math or code. This invariant is true 
of your data structures at every step along the way from input to output, and your algorithms 
should preserve it.
* Contains about 5 unit tests that verify your solution works as intended.
* Contain 500 lines of code that compiles, runs, and passes your tests.
* Contain at least 100 data items, either real or mocked. 

## Real-World Application

The guiding force and north star that will help align your work and give you direction is
your Real-World Application (RWA).

Data structures like arrays and binary search trees, and algorithms like heapsort or 
finding the shortest path, only exist in the abstract, conceptually clean and simple.
When you use them to solve a Real-World Application, you may encounter the following challenges
and need to discuss and work with your team on them.

* Identifying a Real-World Application of a data structure or algorithm in the first place.
* Removing unnecessary details and simplifying (abstraction).
* Modeling the problem with relevant details.
* Generating mock data or collecting real data.
* Code that creates data structures based on the data.
* Algorithms that transform the data in an automated way to a more useful form.
* Examples (at least three) demonstrating running your code on the data you collected and why the 
returned output is expected.
* Instructions on how to run your code.

## Collecting Real Data

Traditionally, we deal with data in table form.
Each table can be called an "entity". Think of a spreadsheet. It has a number of columns, also called "fields",
and a number of rows, which are analogous or "equal" items that all have the same fields, though they may have
different values.

In fact, you may wish to open up a spreadsheet (Excel, or Google Sheets online, or any similar program)
and start collecting data here. When you're ready, somewhere around Week 4 or 5, you can export this data as a 
CSV (Comma-Separated Values) file, read it into your program, and then "hydrate" or "reinflate"

Real data is preferred to mock data in this class, but they each have their uses.

The "smell" of real data and its rough surfaces, distribution of digits, and messy incompleteness
contribute a compelling beauty and internal consistency to your work that will immediately shine 
forth to whoever reads it.

You can start collecting data on Day 1 of the class. The best data is gathered a little at a time,
rather than gradually all at once. You may only vaguely be aware of what to collect, but that's okay.
If you add new columns later on and your early data is missing those columns, you can go back and "backfill"
them as time permits. In conjunction, you can modify your algorithm to gracefully handle missing columns.

Handling missing, incomplete, or invalid data, and also preprocessing or "cleaning up" data is a very 
common operation in Real-World Applications.

